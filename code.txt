// ===== manifest.json =====
{
  "manifest_version": 3,
  "name": "ChatGPT to PDF",
  "version": "2.0",
  "description": "Export ChatGPT conversations to PDF with full markdown support",
  "permissions": ["activeTab", "scripting"],
  "host_permissions": [
    "https://chatgpt.com/*",
    "https://chat.openai.com/*"
  ],
  "action": {
    "default_popup": "popup.html",
    "default_icon": {
      "16": "icon16.png",
      "48": "icon48.png",
      "128": "icon128.png"
    }
  },
  "icons": {
    "16": "icon16.png",
    "48": "icon48.png",
    "128": "icon128.png"
  },
  "web_accessible_resources": [
    {
      "resources": ["jspdf.umd.min.js"],
      "matches": ["https://chatgpt.com/*", "https://chat.openai.com/*"]
    }
  ]
}

// ===== popup.html =====
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <style>
    body {
      width: 320px;
      padding: 20px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
    }
    h2 {
      margin: 0 0 15px 0;
      font-size: 18px;
      color: #10a37f;
    }
    .option {
      margin: 10px 0;
    }
    label {
      display: flex;
      align-items: center;
      cursor: pointer;
      padding: 8px;
      border-radius: 6px;
      transition: background-color 0.2s;
    }
    label:hover {
      background-color: #f7f7f8;
    }
    input[type="radio"] {
      margin-right: 10px;
      cursor: pointer;
    }
    button {
      width: 100%;
      padding: 12px;
      background-color: #10a37f;
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      margin-top: 15px;
      transition: background-color 0.2s;
    }
    button:hover {
      background-color: #0d8c6c;
    }
    button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }
    .status {
      margin-top: 10px;
      padding: 10px;
      border-radius: 6px;
      font-size: 12px;
      text-align: center;
      display: none;
    }
    .status.success {
      background-color: #d4edda;
      color: #155724;
      display: block;
    }
    .status.error {
      background-color: #f8d7da;
      color: #721c24;
      display: block;
    }
    .status.loading {
      background-color: #d1ecf1;
      color: #0c5460;
      display: block;
    }
  </style>
</head>
<body>
  <h2>üí¨ Export to PDF</h2>
  
  <div class="option">
    <label>
      <input type="radio" name="filter" value="both" checked>
      <span>üìù Both (You & ChatGPT)</span>
    </label>
  </div>
  
  <div class="option">
    <label>
      <input type="radio" name="filter" value="user">
      <span>üë§ Your Messages Only</span>
    </label>
  </div>
  
  <div class="option">
    <label>
      <input type="radio" name="filter" value="assistant">
      <span>ü§ñ ChatGPT Responses Only</span>
    </label>
  </div>
  
  <button id="exportBtn">Generate PDF</button>
  
  <div id="status" class="status"></div>
  
  <script src="popup.js"></script>
</body>
</html>

// ===== popup.js =====
document.getElementById('exportBtn').addEventListener('click', async () => {
  const filter = document.querySelector('input[name="filter"]:checked').value;
  const statusDiv = document.getElementById('status');
  const exportBtn = document.getElementById('exportBtn');
  
  statusDiv.className = 'status loading';
  statusDiv.textContent = '‚è≥ Generating PDF...';
  exportBtn.disabled = true;
  
  try {
    const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
    
    if (!tab.url.includes('chatgpt.com') && !tab.url.includes('chat.openai.com')) {
      throw new Error('Please open a ChatGPT conversation first');
    }
    
    // Inject jsPDF library
    await chrome.scripting.executeScript({
      target: { tabId: tab.id },
      files: ['jspdf.umd.min.js']
    });
    
    // Inject and run the PDF generation code
    const results = await chrome.scripting.executeScript({
      target: { tabId: tab.id },
      func: exportChatToPDF,
      args: [filter]
    });
    
    const result = results[0].result;
    
    if (result.success) {
      statusDiv.className = 'status success';
      statusDiv.textContent = `‚úÖ PDF downloaded! (${result.messageCount} messages)`;
    } else {
      throw new Error(result.error || 'Failed to generate PDF');
    }
    
    setTimeout(() => {
      statusDiv.style.display = 'none';
      exportBtn.disabled = false;
    }, 3000);
    
  } catch (error) {
    console.error('Error:', error);
    statusDiv.className = 'status error';
    statusDiv.textContent = '‚ùå ' + error.message;
    exportBtn.disabled = false;
  }
});

// This function runs in the ChatGPT page context
function exportChatToPDF(filter) {
  try {
    if (typeof window.jspdf === 'undefined') {
      throw new Error('jsPDF library not loaded');
    }
    
    const { jsPDF } = window.jspdf;
    
    // Emoji map for common emojis (fallback)
    const emojiMap = {
      'üéâ': '[*]', '‚ú®': '[+]', 'üí°': '[!]', 'üöÄ': '[>>]', 
      '‚ù§Ô∏è': '<3', 'üëç': '[+1]', 'üî•': '[~]', '‚ö°': '[!]',
      'üìù': '[doc]', 'üí¨': '[msg]', 'ü§ñ': '[AI]', 'üë§': '[user]',
      '‚úÖ': '[v]', '‚ùå': '[x]', '‚ö†Ô∏è': '[!]', 'üìä': '[chart]',
      'üéØ': '[o]', 'üîß': '[tool]', 'üì¶': '[box]', 'üåü': '[*]'
    };
    
    // Get title
    let title = 'ChatGPT Conversation';
    const titleElement = document.querySelector('title');
    if (titleElement && titleElement.textContent.trim()) {
      const titleText = titleElement.textContent.trim();
      if (titleText !== 'ChatGPT') {
        title = titleText;
      }
    }
    
    // Extract messages with markdown content
    const messages = [];
    const allElements = document.querySelectorAll('[data-message-author-role]');
    
    allElements.forEach((element) => {
      const role = element.getAttribute('data-message-author-role');
      
      // Get the markdown content container
      const markdownDiv = element.querySelector('[class*="markdown"]') || 
                         element.querySelector('.prose') ||
                         element.querySelector('.whitespace-pre-wrap');
      
      if (!markdownDiv) return;
      
      // Extract content preserving structure
      const content = extractMarkdownContent(markdownDiv);
      
      if (content && content.length > 0) {
        if ((role === 'user' && (filter === 'both' || filter === 'user')) ||
            (role === 'assistant' && (filter === 'both' || filter === 'assistant'))) {
          messages.push({ role, content });
        }
      }
    });
    
    if (messages.length === 0) {
      throw new Error('No messages found in conversation');
    }
    
    // Create PDF with proper formatting
    const doc = new jsPDF();
    let y = 20;
    const pageHeight = doc.internal.pageSize.height;
    const margin = 20;
    const maxWidth = 170;
    
    // Helper to convert emojis
    function replaceEmojis(text) {
      let result = text;
      Object.keys(emojiMap).forEach(emoji => {
        result = result.split(emoji).join(emojiMap[emoji]);
      });
      // Replace any remaining emojis with placeholder
      result = result.replace(/[\u{1F300}-\u{1F9FF}]/gu, '[emoji]');
      return result;
    }
    
    // Title
    doc.setFontSize(16);
    doc.setFont('helvetica', 'bold');
    doc.text(replaceEmojis(title), margin, y);
    y += 10;
    
    // Metadata
    doc.setFontSize(9);
    doc.setFont('helvetica', 'normal');
    doc.setTextColor(100);
    doc.text(`Generated: ${new Date().toLocaleDateString()} | Filter: ${filter} | Messages: ${messages.length}`, margin, y);
    y += 12;
    doc.setTextColor(0);
    
    // Add messages with markdown rendering
    messages.forEach((msg) => {
      y = addMessageToPDF(doc, msg, y, pageHeight, margin, maxWidth, replaceEmojis);
    });
    
    // Save
    const filename = `ChatGPT_${title.substring(0, 20).replace(/[^a-z0-9]/gi, '_')}_${filter}.pdf`;
    doc.save(filename);
    
    return {
      success: true,
      messageCount: messages.length,
      filename: filename
    };
    
  } catch (error) {
    console.error('PDF Error:', error);
    return {
      success: false,
      error: error.message
    };
  }
  
  // Helper function to extract markdown content
  function extractMarkdownContent(element) {
    const contentParts = [];
    
    function traverse(node) {
      if (node.nodeType === Node.TEXT_NODE) {
        const text = node.textContent;
        if (text.trim()) {
          contentParts.push({ type: 'text', content: text });
        }
      } else if (node.nodeType === Node.ELEMENT_NODE) {
        const tagName = node.tagName.toLowerCase();
        
        // Headers
        if (tagName.match(/^h[1-6]$/)) {
          contentParts.push({ 
            type: 'header', 
            level: parseInt(tagName[1]),
            content: node.textContent.trim() 
          });
        }
        // Horizontal rule / separator
        else if (tagName === 'hr') {
          contentParts.push({ type: 'separator' });
        }
        // Line breaks
        else if (tagName === 'br') {
          contentParts.push({ type: 'line_break' });
        }
        // Code blocks
        else if (tagName === 'pre') {
          const codeElement = node.querySelector('code');
          const code = codeElement ? codeElement.textContent : node.textContent;
          const language = codeElement ? codeElement.className.replace('language-', '').replace('hljs', '').trim() : '';
          contentParts.push({ 
            type: 'code_block', 
            content: code.trim(),
            language: language
          });
        }
        // Inline code
        else if (tagName === 'code' && node.parentElement.tagName.toLowerCase() !== 'pre') {
          contentParts.push({ 
            type: 'inline_code', 
            content: node.textContent 
          });
        }
        // Bold
        else if (tagName === 'strong' || tagName === 'b') {
          contentParts.push({ 
            type: 'bold', 
            content: node.textContent 
          });
        }
        // Italic
        else if (tagName === 'em' || tagName === 'i') {
          contentParts.push({ 
            type: 'italic', 
            content: node.textContent 
          });
        }
        // Blockquote
        else if (tagName === 'blockquote') {
          contentParts.push({ 
            type: 'blockquote', 
            content: node.textContent.trim() 
          });
        }
        // Lists
        else if (tagName === 'ul' || tagName === 'ol') {
          const items = Array.from(node.querySelectorAll('li')).map(li => li.textContent.trim());
          contentParts.push({ 
            type: tagName === 'ul' ? 'unordered_list' : 'ordered_list', 
            items: items 
          });
        }
        // Tables
        else if (tagName === 'table') {
          const headers = Array.from(node.querySelectorAll('thead th')).map(th => th.textContent.trim());
          const rows = Array.from(node.querySelectorAll('tbody tr')).map(tr => 
            Array.from(tr.querySelectorAll('td')).map(td => td.textContent.trim())
          );
          if (headers.length > 0 || rows.length > 0) {
            contentParts.push({ 
              type: 'table', 
              headers: headers,
              rows: rows 
            });
          }
        }
        // Links
        else if (tagName === 'a') {
          const href = node.getAttribute('href');
          const text = node.textContent.trim();
          contentParts.push({ 
            type: 'link', 
            text: text,
            url: href 
          });
        }
        // Paragraphs
        else if (tagName === 'p') {
          node.childNodes.forEach(child => traverse(child));
          contentParts.push({ type: 'paragraph_break' });
        }
        // Other elements - traverse children
        else {
          node.childNodes.forEach(child => traverse(child));
        }
      }
    }
    
    traverse(element);
    return contentParts;
  }
  
  // Helper function to add message to PDF with formatting
  function addMessageToPDF(doc, msg, y, pageHeight, margin, maxWidth, replaceEmojis) {
    // Check if we need a new page
    if (y > pageHeight - 40) {
      doc.addPage();
      y = 20;
    }
    
    // Role header
    doc.setFontSize(11);
    doc.setFont('helvetica', 'bold');
    
    if (msg.role === 'user') {
      doc.setTextColor(0, 0, 0);
      doc.text('[user] You', margin, y);
    } else {
      doc.setTextColor(16, 163, 127);
      doc.text('[AI] ChatGPT', margin, y);
    }
    
    y += 8;
    doc.setTextColor(0, 0, 0);
    
    // Process content parts
    msg.content.forEach(part => {
      if (y > pageHeight - 20) {
        doc.addPage();
        y = 20;
      }
      
      switch (part.type) {
        case 'header':
          doc.setFont('helvetica', 'bold');
          doc.setFontSize(14 - part.level);
          const headerText = replaceEmojis(part.content);
          const headerLines = doc.splitTextToSize(headerText, maxWidth);
          headerLines.forEach(line => {
            if (y > pageHeight - 15) {
              doc.addPage();
              y = 20;
            }
            doc.text(line, margin, y);
            y += 7;
          });
          doc.setFontSize(10);
          doc.setFont('helvetica', 'normal');
          y += 3;
          break;
          
        case 'code_block':
          doc.setFont('courier', 'normal');
          doc.setFontSize(8);
          doc.setFillColor(245, 245, 245);
          
          // Add language label if present
          if (part.language) {
            doc.setTextColor(100);
            doc.text(`[${part.language}]`, margin, y);
            y += 5;
            doc.setTextColor(0);
          }
          
          const codeLines = part.content.split('\n');
          codeLines.forEach(line => {
            if (y > pageHeight - 15) {
              doc.addPage();
              y = 20;
            }
            // Background for code
            const lineWidth = maxWidth + 4;
            doc.rect(margin - 2, y - 4, lineWidth, 5, 'F');
            doc.text(line || ' ', margin, y);
            y += 5;
          });
          
          doc.setFont('helvetica', 'normal');
          doc.setFontSize(10);
          y += 5;
          break;
          
        case 'inline_code':
          doc.setFont('courier', 'normal');
          doc.setTextColor(199, 37, 78);
          doc.setFontSize(9);
          doc.text(part.content, margin, y);
          doc.setFont('helvetica', 'normal');
          doc.setFontSize(10);
          doc.setTextColor(0);
          y += 5;
          break;
          
        case 'bold':
          doc.setFont('helvetica', 'bold');
          const boldText = replaceEmojis(part.content);
          const boldLines = doc.splitTextToSize(boldText, maxWidth);
          boldLines.forEach(line => {
            if (y > pageHeight - 15) {
              doc.addPage();
              y = 20;
            }
            doc.text(line, margin, y);
            y += 5;
          });
          doc.setFont('helvetica', 'normal');
          break;
          
        case 'italic':
          doc.setFont('helvetica', 'italic');
          const italicText = replaceEmojis(part.content);
          const italicLines = doc.splitTextToSize(italicText, maxWidth);
          italicLines.forEach(line => {
            if (y > pageHeight - 15) {
              doc.addPage();
              y = 20;
            }
            doc.text(line, margin, y);
            y += 5;
          });
          doc.setFont('helvetica', 'normal');
          break;
          
        case 'blockquote':
          doc.setFont('helvetica', 'italic');
          doc.setTextColor(100);
          const quoteText = replaceEmojis(part.content);
          const quoteLines = doc.splitTextToSize('> ' + quoteText, maxWidth - 5);
          quoteLines.forEach(line => {
            if (y > pageHeight - 15) {
              doc.addPage();
              y = 20;
            }
            doc.text(line, margin + 5, y);
            y += 5;
          });
          doc.setTextColor(0);
          doc.setFont('helvetica', 'normal');
          y += 3;
          break;
          
        case 'unordered_list':
        case 'ordered_list':
          part.items.forEach((item, index) => {
            if (y > pageHeight - 15) {
              doc.addPage();
              y = 20;
            }
            const bullet = part.type === 'unordered_list' ? '‚Ä¢' : `${index + 1}.`;
            doc.text(bullet, margin, y);
            const itemText = replaceEmojis(item);
            const itemLines = doc.splitTextToSize(itemText, maxWidth - 10);
            itemLines.forEach((line, i) => {
              if (y > pageHeight - 15) {
                doc.addPage();
                y = 20;
              }
              doc.text(line, margin + 8, y);
              if (i < itemLines.length - 1) y += 5;
            });
            y += 6;
          });
          y += 3;
          break;
          
        case 'table':
          // Simple table rendering
          if (part.headers.length > 0) {
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(9);
            const headerText = part.headers.join(' | ');
            doc.text(headerText, margin, y);
            y += 5;
            doc.setFont('helvetica', 'normal');
          }
          
          part.rows.forEach(row => {
            if (y > pageHeight - 15) {
              doc.addPage();
              y = 20;
            }
            const rowText = row.join(' | ');
            doc.text(rowText, margin, y);
            y += 5;
          });
          y += 5;
          break;
          
        case 'link':
          doc.setFont('helvetica', 'normal');
          doc.setTextColor(0, 0, 238);
          doc.textWithLink(part.text || part.url, margin, y, { url: part.url });
          doc.setTextColor(0);
          y += 5;
          break;
          
        case 'text':
          doc.setFont('helvetica', 'normal');
          doc.setFontSize(10);
          
          const textContent = replaceEmojis(part.content);
          const textLines = doc.splitTextToSize(textContent, maxWidth);
          
          textLines.forEach(line => {
            if (y > pageHeight - 15) {
              doc.addPage();
              y = 20;
            }
            doc.text(line, margin, y);
            y += 5;
          });
          break;
          
        case 'separator':
          if (y > pageHeight - 15) {
            doc.addPage();
            y = 20;
          }
          // Draw horizontal line
          doc.setDrawColor(200, 200, 200);
          doc.setLineWidth(0.5);
          doc.line(margin, y, margin + maxWidth, y);
          y += 8;
          break;
          
        case 'line_break':
          y += 5;
          break;
          
        case 'paragraph_break':
          y += 4;
          break;
      }
    });
    
    y += 10;
    return y;
  }
}

